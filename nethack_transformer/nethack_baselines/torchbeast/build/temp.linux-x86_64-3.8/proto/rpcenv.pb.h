// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpcenv.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rpcenv_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rpcenv_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rpcenv_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rpcenv_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rpcenv_2eproto;
namespace rpcenv {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ArrayNest;
class ArrayNestDefaultTypeInternal;
extern ArrayNestDefaultTypeInternal _ArrayNest_default_instance_;
class ArrayNest_MapEntry_DoNotUse;
class ArrayNest_MapEntry_DoNotUseDefaultTypeInternal;
extern ArrayNest_MapEntry_DoNotUseDefaultTypeInternal _ArrayNest_MapEntry_DoNotUse_default_instance_;
class NDArray;
class NDArrayDefaultTypeInternal;
extern NDArrayDefaultTypeInternal _NDArray_default_instance_;
class Step;
class StepDefaultTypeInternal;
extern StepDefaultTypeInternal _Step_default_instance_;
}  // namespace rpcenv
PROTOBUF_NAMESPACE_OPEN
template<> ::rpcenv::Action* Arena::CreateMaybeMessage<::rpcenv::Action>(Arena*);
template<> ::rpcenv::ArrayNest* Arena::CreateMaybeMessage<::rpcenv::ArrayNest>(Arena*);
template<> ::rpcenv::ArrayNest_MapEntry_DoNotUse* Arena::CreateMaybeMessage<::rpcenv::ArrayNest_MapEntry_DoNotUse>(Arena*);
template<> ::rpcenv::NDArray* Arena::CreateMaybeMessage<::rpcenv::NDArray>(Arena*);
template<> ::rpcenv::Step* Arena::CreateMaybeMessage<::rpcenv::Step>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rpcenv {

// ===================================================================

class Action PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpcenv.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  virtual ~Action();

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Action& default_instance();

  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(nullptr);
  }

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpcenv.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rpcenv_2eproto);
    return ::descriptor_table_rpcenv_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNestActionFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // optional .rpcenv.ArrayNest nest_action = 2;
  bool has_nest_action() const;
  private:
  bool _internal_has_nest_action() const;
  public:
  void clear_nest_action();
  const ::rpcenv::ArrayNest& nest_action() const;
  ::rpcenv::ArrayNest* release_nest_action();
  ::rpcenv::ArrayNest* mutable_nest_action();
  void set_allocated_nest_action(::rpcenv::ArrayNest* nest_action);
  private:
  const ::rpcenv::ArrayNest& _internal_nest_action() const;
  ::rpcenv::ArrayNest* _internal_mutable_nest_action();
  public:
  void unsafe_arena_set_allocated_nest_action(
      ::rpcenv::ArrayNest* nest_action);
  ::rpcenv::ArrayNest* unsafe_arena_release_nest_action();

  // optional int32 action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::PROTOBUF_NAMESPACE_ID::int32 action() const;
  void set_action(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_action() const;
  void _internal_set_action(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:rpcenv.Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rpcenv::ArrayNest* nest_action_;
  ::PROTOBUF_NAMESPACE_ID::int32 action_;
  friend struct ::TableStruct_rpcenv_2eproto;
};
// -------------------------------------------------------------------

class NDArray PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpcenv.NDArray) */ {
 public:
  inline NDArray() : NDArray(nullptr) {}
  virtual ~NDArray();

  NDArray(const NDArray& from);
  NDArray(NDArray&& from) noexcept
    : NDArray() {
    *this = ::std::move(from);
  }

  inline NDArray& operator=(const NDArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline NDArray& operator=(NDArray&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NDArray& default_instance();

  static inline const NDArray* internal_default_instance() {
    return reinterpret_cast<const NDArray*>(
               &_NDArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NDArray& a, NDArray& b) {
    a.Swap(&b);
  }
  inline void Swap(NDArray* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NDArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NDArray* New() const final {
    return CreateMaybeMessage<NDArray>(nullptr);
  }

  NDArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NDArray>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NDArray& from);
  void MergeFrom(const NDArray& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NDArray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpcenv.NDArray";
  }
  protected:
  explicit NDArray(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rpcenv_2eproto);
    return ::descriptor_table_rpcenv_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 2,
    kDataFieldNumber = 3,
    kDtypeFieldNumber = 1,
  };
  // repeated int64 shape = 2 [packed = true];
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_shape() const;
  void _internal_add_shape(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_shape();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 shape(int index) const;
  void set_shape(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_shape(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_shape();

  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional int32 dtype = 1;
  bool has_dtype() const;
  private:
  bool _internal_has_dtype() const;
  public:
  void clear_dtype();
  ::PROTOBUF_NAMESPACE_ID::int32 dtype() const;
  void set_dtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dtype() const;
  void _internal_set_dtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:rpcenv.NDArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 dtype_;
  friend struct ::TableStruct_rpcenv_2eproto;
};
// -------------------------------------------------------------------

class ArrayNest_MapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ArrayNest_MapEntry_DoNotUse, 
    std::string, ::rpcenv::ArrayNest,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ArrayNest_MapEntry_DoNotUse, 
    std::string, ::rpcenv::ArrayNest,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ArrayNest_MapEntry_DoNotUse();
  explicit ArrayNest_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ArrayNest_MapEntry_DoNotUse& other);
  static const ArrayNest_MapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ArrayNest_MapEntry_DoNotUse*>(&_ArrayNest_MapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "rpcenv.ArrayNest.MapEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rpcenv_2eproto);
    return ::descriptor_table_rpcenv_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class ArrayNest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpcenv.ArrayNest) */ {
 public:
  inline ArrayNest() : ArrayNest(nullptr) {}
  virtual ~ArrayNest();

  ArrayNest(const ArrayNest& from);
  ArrayNest(ArrayNest&& from) noexcept
    : ArrayNest() {
    *this = ::std::move(from);
  }

  inline ArrayNest& operator=(const ArrayNest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayNest& operator=(ArrayNest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ArrayNest& default_instance();

  static inline const ArrayNest* internal_default_instance() {
    return reinterpret_cast<const ArrayNest*>(
               &_ArrayNest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ArrayNest& a, ArrayNest& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayNest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayNest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArrayNest* New() const final {
    return CreateMaybeMessage<ArrayNest>(nullptr);
  }

  ArrayNest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArrayNest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ArrayNest& from);
  void MergeFrom(const ArrayNest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrayNest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpcenv.ArrayNest";
  }
  protected:
  explicit ArrayNest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rpcenv_2eproto);
    return ::descriptor_table_rpcenv_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 2,
    kMapFieldNumber = 3,
    kArrayFieldNumber = 1,
  };
  // repeated .rpcenv.ArrayNest vector = 2;
  int vector_size() const;
  private:
  int _internal_vector_size() const;
  public:
  void clear_vector();
  ::rpcenv::ArrayNest* mutable_vector(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rpcenv::ArrayNest >*
      mutable_vector();
  private:
  const ::rpcenv::ArrayNest& _internal_vector(int index) const;
  ::rpcenv::ArrayNest* _internal_add_vector();
  public:
  const ::rpcenv::ArrayNest& vector(int index) const;
  ::rpcenv::ArrayNest* add_vector();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rpcenv::ArrayNest >&
      vector() const;

  // map<string, .rpcenv.ArrayNest> map = 3;
  int map_size() const;
  private:
  int _internal_map_size() const;
  public:
  void clear_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >&
      _internal_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >*
      _internal_mutable_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >&
      map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >*
      mutable_map();

  // optional .rpcenv.NDArray array = 1;
  bool has_array() const;
  private:
  bool _internal_has_array() const;
  public:
  void clear_array();
  const ::rpcenv::NDArray& array() const;
  ::rpcenv::NDArray* release_array();
  ::rpcenv::NDArray* mutable_array();
  void set_allocated_array(::rpcenv::NDArray* array);
  private:
  const ::rpcenv::NDArray& _internal_array() const;
  ::rpcenv::NDArray* _internal_mutable_array();
  public:
  void unsafe_arena_set_allocated_array(
      ::rpcenv::NDArray* array);
  ::rpcenv::NDArray* unsafe_arena_release_array();

  // @@protoc_insertion_point(class_scope:rpcenv.ArrayNest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rpcenv::ArrayNest > vector_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ArrayNest_MapEntry_DoNotUse,
      std::string, ::rpcenv::ArrayNest,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> map_;
  ::rpcenv::NDArray* array_;
  friend struct ::TableStruct_rpcenv_2eproto;
};
// -------------------------------------------------------------------

class Step PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpcenv.Step) */ {
 public:
  inline Step() : Step(nullptr) {}
  virtual ~Step();

  Step(const Step& from);
  Step(Step&& from) noexcept
    : Step() {
    *this = ::std::move(from);
  }

  inline Step& operator=(const Step& from) {
    CopyFrom(from);
    return *this;
  }
  inline Step& operator=(Step&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Step& default_instance();

  static inline const Step* internal_default_instance() {
    return reinterpret_cast<const Step*>(
               &_Step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Step& a, Step& b) {
    a.Swap(&b);
  }
  inline void Swap(Step* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Step* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Step* New() const final {
    return CreateMaybeMessage<Step>(nullptr);
  }

  Step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Step>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Step& from);
  void MergeFrom(const Step& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Step* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpcenv.Step";
  }
  protected:
  explicit Step(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rpcenv_2eproto);
    return ::descriptor_table_rpcenv_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObservationFieldNumber = 1,
    kRewardFieldNumber = 2,
    kDoneFieldNumber = 3,
    kEpisodeStepFieldNumber = 4,
    kEpisodeReturnFieldNumber = 5,
  };
  // optional .rpcenv.ArrayNest observation = 1;
  bool has_observation() const;
  private:
  bool _internal_has_observation() const;
  public:
  void clear_observation();
  const ::rpcenv::ArrayNest& observation() const;
  ::rpcenv::ArrayNest* release_observation();
  ::rpcenv::ArrayNest* mutable_observation();
  void set_allocated_observation(::rpcenv::ArrayNest* observation);
  private:
  const ::rpcenv::ArrayNest& _internal_observation() const;
  ::rpcenv::ArrayNest* _internal_mutable_observation();
  public:
  void unsafe_arena_set_allocated_observation(
      ::rpcenv::ArrayNest* observation);
  ::rpcenv::ArrayNest* unsafe_arena_release_observation();

  // optional float reward = 2;
  bool has_reward() const;
  private:
  bool _internal_has_reward() const;
  public:
  void clear_reward();
  float reward() const;
  void set_reward(float value);
  private:
  float _internal_reward() const;
  void _internal_set_reward(float value);
  public:

  // optional bool done = 3;
  bool has_done() const;
  private:
  bool _internal_has_done() const;
  public:
  void clear_done();
  bool done() const;
  void set_done(bool value);
  private:
  bool _internal_done() const;
  void _internal_set_done(bool value);
  public:

  // optional int32 episode_step = 4;
  bool has_episode_step() const;
  private:
  bool _internal_has_episode_step() const;
  public:
  void clear_episode_step();
  ::PROTOBUF_NAMESPACE_ID::int32 episode_step() const;
  void set_episode_step(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_episode_step() const;
  void _internal_set_episode_step(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float episode_return = 5;
  bool has_episode_return() const;
  private:
  bool _internal_has_episode_return() const;
  public:
  void clear_episode_return();
  float episode_return() const;
  void set_episode_return(float value);
  private:
  float _internal_episode_return() const;
  void _internal_set_episode_return(float value);
  public:

  // @@protoc_insertion_point(class_scope:rpcenv.Step)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rpcenv::ArrayNest* observation_;
  float reward_;
  bool done_;
  ::PROTOBUF_NAMESPACE_ID::int32 episode_step_;
  float episode_return_;
  friend struct ::TableStruct_rpcenv_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Action

// optional int32 action = 1;
inline bool Action::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Action::has_action() const {
  return _internal_has_action();
}
inline void Action::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Action::_internal_action() const {
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Action::action() const {
  // @@protoc_insertion_point(field_get:rpcenv.Action.action)
  return _internal_action();
}
inline void Action::_internal_set_action(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  action_ = value;
}
inline void Action::set_action(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:rpcenv.Action.action)
}

// optional .rpcenv.ArrayNest nest_action = 2;
inline bool Action::_internal_has_nest_action() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nest_action_ != nullptr);
  return value;
}
inline bool Action::has_nest_action() const {
  return _internal_has_nest_action();
}
inline void Action::clear_nest_action() {
  if (nest_action_ != nullptr) nest_action_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rpcenv::ArrayNest& Action::_internal_nest_action() const {
  const ::rpcenv::ArrayNest* p = nest_action_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpcenv::ArrayNest&>(
      ::rpcenv::_ArrayNest_default_instance_);
}
inline const ::rpcenv::ArrayNest& Action::nest_action() const {
  // @@protoc_insertion_point(field_get:rpcenv.Action.nest_action)
  return _internal_nest_action();
}
inline void Action::unsafe_arena_set_allocated_nest_action(
    ::rpcenv::ArrayNest* nest_action) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nest_action_);
  }
  nest_action_ = nest_action;
  if (nest_action) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpcenv.Action.nest_action)
}
inline ::rpcenv::ArrayNest* Action::release_nest_action() {
  _has_bits_[0] &= ~0x00000001u;
  ::rpcenv::ArrayNest* temp = nest_action_;
  nest_action_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::rpcenv::ArrayNest* Action::unsafe_arena_release_nest_action() {
  // @@protoc_insertion_point(field_release:rpcenv.Action.nest_action)
  _has_bits_[0] &= ~0x00000001u;
  ::rpcenv::ArrayNest* temp = nest_action_;
  nest_action_ = nullptr;
  return temp;
}
inline ::rpcenv::ArrayNest* Action::_internal_mutable_nest_action() {
  _has_bits_[0] |= 0x00000001u;
  if (nest_action_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpcenv::ArrayNest>(GetArena());
    nest_action_ = p;
  }
  return nest_action_;
}
inline ::rpcenv::ArrayNest* Action::mutable_nest_action() {
  // @@protoc_insertion_point(field_mutable:rpcenv.Action.nest_action)
  return _internal_mutable_nest_action();
}
inline void Action::set_allocated_nest_action(::rpcenv::ArrayNest* nest_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nest_action_;
  }
  if (nest_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nest_action);
    if (message_arena != submessage_arena) {
      nest_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nest_action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nest_action_ = nest_action;
  // @@protoc_insertion_point(field_set_allocated:rpcenv.Action.nest_action)
}

// -------------------------------------------------------------------

// NDArray

// optional int32 dtype = 1;
inline bool NDArray::_internal_has_dtype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NDArray::has_dtype() const {
  return _internal_has_dtype();
}
inline void NDArray::clear_dtype() {
  dtype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NDArray::_internal_dtype() const {
  return dtype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NDArray::dtype() const {
  // @@protoc_insertion_point(field_get:rpcenv.NDArray.dtype)
  return _internal_dtype();
}
inline void NDArray::_internal_set_dtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  dtype_ = value;
}
inline void NDArray::set_dtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dtype(value);
  // @@protoc_insertion_point(field_set:rpcenv.NDArray.dtype)
}

// repeated int64 shape = 2 [packed = true];
inline int NDArray::_internal_shape_size() const {
  return shape_.size();
}
inline int NDArray::shape_size() const {
  return _internal_shape_size();
}
inline void NDArray::clear_shape() {
  shape_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NDArray::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NDArray::shape(int index) const {
  // @@protoc_insertion_point(field_get:rpcenv.NDArray.shape)
  return _internal_shape(index);
}
inline void NDArray::set_shape(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:rpcenv.NDArray.shape)
}
inline void NDArray::_internal_add_shape(::PROTOBUF_NAMESPACE_ID::int64 value) {
  shape_.Add(value);
}
inline void NDArray::add_shape(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:rpcenv.NDArray.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
NDArray::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
NDArray::shape() const {
  // @@protoc_insertion_point(field_list:rpcenv.NDArray.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
NDArray::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
NDArray::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:rpcenv.NDArray.shape)
  return _internal_mutable_shape();
}

// optional bytes data = 3;
inline bool NDArray::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NDArray::has_data() const {
  return _internal_has_data();
}
inline void NDArray::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NDArray::data() const {
  // @@protoc_insertion_point(field_get:rpcenv.NDArray.data)
  return _internal_data();
}
inline void NDArray::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:rpcenv.NDArray.data)
}
inline std::string* NDArray::mutable_data() {
  // @@protoc_insertion_point(field_mutable:rpcenv.NDArray.data)
  return _internal_mutable_data();
}
inline const std::string& NDArray::_internal_data() const {
  return data_.Get();
}
inline void NDArray::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NDArray::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rpcenv.NDArray.data)
}
inline void NDArray::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:rpcenv.NDArray.data)
}
inline void NDArray::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rpcenv.NDArray.data)
}
inline std::string* NDArray::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NDArray::release_data() {
  // @@protoc_insertion_point(field_release:rpcenv.NDArray.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NDArray::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rpcenv.NDArray.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ArrayNest

// optional .rpcenv.NDArray array = 1;
inline bool ArrayNest::_internal_has_array() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || array_ != nullptr);
  return value;
}
inline bool ArrayNest::has_array() const {
  return _internal_has_array();
}
inline void ArrayNest::clear_array() {
  if (array_ != nullptr) array_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rpcenv::NDArray& ArrayNest::_internal_array() const {
  const ::rpcenv::NDArray* p = array_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpcenv::NDArray&>(
      ::rpcenv::_NDArray_default_instance_);
}
inline const ::rpcenv::NDArray& ArrayNest::array() const {
  // @@protoc_insertion_point(field_get:rpcenv.ArrayNest.array)
  return _internal_array();
}
inline void ArrayNest::unsafe_arena_set_allocated_array(
    ::rpcenv::NDArray* array) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(array_);
  }
  array_ = array;
  if (array) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpcenv.ArrayNest.array)
}
inline ::rpcenv::NDArray* ArrayNest::release_array() {
  _has_bits_[0] &= ~0x00000001u;
  ::rpcenv::NDArray* temp = array_;
  array_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::rpcenv::NDArray* ArrayNest::unsafe_arena_release_array() {
  // @@protoc_insertion_point(field_release:rpcenv.ArrayNest.array)
  _has_bits_[0] &= ~0x00000001u;
  ::rpcenv::NDArray* temp = array_;
  array_ = nullptr;
  return temp;
}
inline ::rpcenv::NDArray* ArrayNest::_internal_mutable_array() {
  _has_bits_[0] |= 0x00000001u;
  if (array_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpcenv::NDArray>(GetArena());
    array_ = p;
  }
  return array_;
}
inline ::rpcenv::NDArray* ArrayNest::mutable_array() {
  // @@protoc_insertion_point(field_mutable:rpcenv.ArrayNest.array)
  return _internal_mutable_array();
}
inline void ArrayNest::set_allocated_array(::rpcenv::NDArray* array) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete array_;
  }
  if (array) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(array);
    if (message_arena != submessage_arena) {
      array = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, array, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  array_ = array;
  // @@protoc_insertion_point(field_set_allocated:rpcenv.ArrayNest.array)
}

// repeated .rpcenv.ArrayNest vector = 2;
inline int ArrayNest::_internal_vector_size() const {
  return vector_.size();
}
inline int ArrayNest::vector_size() const {
  return _internal_vector_size();
}
inline void ArrayNest::clear_vector() {
  vector_.Clear();
}
inline ::rpcenv::ArrayNest* ArrayNest::mutable_vector(int index) {
  // @@protoc_insertion_point(field_mutable:rpcenv.ArrayNest.vector)
  return vector_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rpcenv::ArrayNest >*
ArrayNest::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:rpcenv.ArrayNest.vector)
  return &vector_;
}
inline const ::rpcenv::ArrayNest& ArrayNest::_internal_vector(int index) const {
  return vector_.Get(index);
}
inline const ::rpcenv::ArrayNest& ArrayNest::vector(int index) const {
  // @@protoc_insertion_point(field_get:rpcenv.ArrayNest.vector)
  return _internal_vector(index);
}
inline ::rpcenv::ArrayNest* ArrayNest::_internal_add_vector() {
  return vector_.Add();
}
inline ::rpcenv::ArrayNest* ArrayNest::add_vector() {
  // @@protoc_insertion_point(field_add:rpcenv.ArrayNest.vector)
  return _internal_add_vector();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rpcenv::ArrayNest >&
ArrayNest::vector() const {
  // @@protoc_insertion_point(field_list:rpcenv.ArrayNest.vector)
  return vector_;
}

// map<string, .rpcenv.ArrayNest> map = 3;
inline int ArrayNest::_internal_map_size() const {
  return map_.size();
}
inline int ArrayNest::map_size() const {
  return _internal_map_size();
}
inline void ArrayNest::clear_map() {
  map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >&
ArrayNest::_internal_map() const {
  return map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >&
ArrayNest::map() const {
  // @@protoc_insertion_point(field_map:rpcenv.ArrayNest.map)
  return _internal_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >*
ArrayNest::_internal_mutable_map() {
  return map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rpcenv::ArrayNest >*
ArrayNest::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:rpcenv.ArrayNest.map)
  return _internal_mutable_map();
}

// -------------------------------------------------------------------

// Step

// optional .rpcenv.ArrayNest observation = 1;
inline bool Step::_internal_has_observation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || observation_ != nullptr);
  return value;
}
inline bool Step::has_observation() const {
  return _internal_has_observation();
}
inline void Step::clear_observation() {
  if (observation_ != nullptr) observation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rpcenv::ArrayNest& Step::_internal_observation() const {
  const ::rpcenv::ArrayNest* p = observation_;
  return p != nullptr ? *p : reinterpret_cast<const ::rpcenv::ArrayNest&>(
      ::rpcenv::_ArrayNest_default_instance_);
}
inline const ::rpcenv::ArrayNest& Step::observation() const {
  // @@protoc_insertion_point(field_get:rpcenv.Step.observation)
  return _internal_observation();
}
inline void Step::unsafe_arena_set_allocated_observation(
    ::rpcenv::ArrayNest* observation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(observation_);
  }
  observation_ = observation;
  if (observation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rpcenv.Step.observation)
}
inline ::rpcenv::ArrayNest* Step::release_observation() {
  _has_bits_[0] &= ~0x00000001u;
  ::rpcenv::ArrayNest* temp = observation_;
  observation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::rpcenv::ArrayNest* Step::unsafe_arena_release_observation() {
  // @@protoc_insertion_point(field_release:rpcenv.Step.observation)
  _has_bits_[0] &= ~0x00000001u;
  ::rpcenv::ArrayNest* temp = observation_;
  observation_ = nullptr;
  return temp;
}
inline ::rpcenv::ArrayNest* Step::_internal_mutable_observation() {
  _has_bits_[0] |= 0x00000001u;
  if (observation_ == nullptr) {
    auto* p = CreateMaybeMessage<::rpcenv::ArrayNest>(GetArena());
    observation_ = p;
  }
  return observation_;
}
inline ::rpcenv::ArrayNest* Step::mutable_observation() {
  // @@protoc_insertion_point(field_mutable:rpcenv.Step.observation)
  return _internal_mutable_observation();
}
inline void Step::set_allocated_observation(::rpcenv::ArrayNest* observation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete observation_;
  }
  if (observation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(observation);
    if (message_arena != submessage_arena) {
      observation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, observation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  observation_ = observation;
  // @@protoc_insertion_point(field_set_allocated:rpcenv.Step.observation)
}

// optional float reward = 2;
inline bool Step::_internal_has_reward() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Step::has_reward() const {
  return _internal_has_reward();
}
inline void Step::clear_reward() {
  reward_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Step::_internal_reward() const {
  return reward_;
}
inline float Step::reward() const {
  // @@protoc_insertion_point(field_get:rpcenv.Step.reward)
  return _internal_reward();
}
inline void Step::_internal_set_reward(float value) {
  _has_bits_[0] |= 0x00000002u;
  reward_ = value;
}
inline void Step::set_reward(float value) {
  _internal_set_reward(value);
  // @@protoc_insertion_point(field_set:rpcenv.Step.reward)
}

// optional bool done = 3;
inline bool Step::_internal_has_done() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Step::has_done() const {
  return _internal_has_done();
}
inline void Step::clear_done() {
  done_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Step::_internal_done() const {
  return done_;
}
inline bool Step::done() const {
  // @@protoc_insertion_point(field_get:rpcenv.Step.done)
  return _internal_done();
}
inline void Step::_internal_set_done(bool value) {
  _has_bits_[0] |= 0x00000004u;
  done_ = value;
}
inline void Step::set_done(bool value) {
  _internal_set_done(value);
  // @@protoc_insertion_point(field_set:rpcenv.Step.done)
}

// optional int32 episode_step = 4;
inline bool Step::_internal_has_episode_step() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Step::has_episode_step() const {
  return _internal_has_episode_step();
}
inline void Step::clear_episode_step() {
  episode_step_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Step::_internal_episode_step() const {
  return episode_step_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Step::episode_step() const {
  // @@protoc_insertion_point(field_get:rpcenv.Step.episode_step)
  return _internal_episode_step();
}
inline void Step::_internal_set_episode_step(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  episode_step_ = value;
}
inline void Step::set_episode_step(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_episode_step(value);
  // @@protoc_insertion_point(field_set:rpcenv.Step.episode_step)
}

// optional float episode_return = 5;
inline bool Step::_internal_has_episode_return() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Step::has_episode_return() const {
  return _internal_has_episode_return();
}
inline void Step::clear_episode_return() {
  episode_return_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Step::_internal_episode_return() const {
  return episode_return_;
}
inline float Step::episode_return() const {
  // @@protoc_insertion_point(field_get:rpcenv.Step.episode_return)
  return _internal_episode_return();
}
inline void Step::_internal_set_episode_return(float value) {
  _has_bits_[0] |= 0x00000010u;
  episode_return_ = value;
}
inline void Step::set_episode_return(float value) {
  _internal_set_episode_return(value);
  // @@protoc_insertion_point(field_set:rpcenv.Step.episode_return)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpcenv

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rpcenv_2eproto
